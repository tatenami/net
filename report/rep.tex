% ファイル先頭から\begin{document}までの内容（プレアンブル）については，
% 基本的に { } の中を書き換えるだけでよい．
\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}

%%======== プレアンブル ============================================%%
% 用紙設定：指示があれば，適切な余白に設定しなおす
\RequirePackage{geometry}
\geometry{reset,paperwidth=210truemm,paperheight=297truemm}
\geometry{hmargin=25truemm,top=20truemm,bottom=25truemm,footskip=10truemm,headheight=0mm}
%\geometry{showframe} % 本文の"枠"を確認したければ，コメントアウト

% 設定：図の挿入
% http://www.edu.cs.okayama-u.ac.jp/info/tool_guide/tex.html#graphicx
\usepackage{graphicx}

% 設定：ソースコードの挿入
% http://www.edu.cs.okayama-u.ac.jp/info/tool_guide/tex.html#fancyvrb
\usepackage{fancyvrb}
\renewcommand{\theFancyVerbLine}{\texttt{\footnotesize{\arabic{FancyVerbLine}:}}}

%%======== レポートタイトル等 ======================================%%
% ToDo: 提出要領に従って，適切なタイトル・サブタイトルを設定する
\title{情報工学実験C ネットワーク実験課題レポート \\
       |\large{クライアントサーバーモデルで動作する名簿管理プログラムの作成}|}

% ToDo: 自分自身の氏名と学生番号に書き換える
\author{氏名: 寺岡 久騎 (TERAOKA, Hisaki) \\
        学生番号: 09B22433}

% ToDo: レポート課題等の指示に従って適切に書き換える
\date{出題日: 2024年12月13日 \\
      提出日: 2025年 1月21日 \\
      締切日: 2025年 1月21日 \\}  % 注：最後の\\は不要に見えるが必要．


%%======== 本文 ====================================================%%
\begin{document}
\maketitle
% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

%% 本文は以下に書く．課題に応じて適切な章立てを構成すること．
%% 章＝\section，節＝\subsection，項＝\subsubsection である．

%--------------------------------------------------------------------%
% \section{概要} \label{sec:abstract}


%--------------------------------------------------------------------%
\section{プログラムの処理の概要および作成方針}
本実験では，ネットワーク通信により動作するクライアントサーバーモデルの
TCPによる相互のデータ送受信を行う名簿管理プログラムの作成を行った．
本章ではサーバ・クライアントプログラムのそれぞれの機能と，
プログラム全体としての処理の概要について解説する．

\subsection{プログラム全体の処理の流れと概要} \label{sec:prog-flow}
プログラム全体の処理の流れとして，まず
サーバはクライアントからのTCPの接続要求を待ち受け，クライアント
はサーバに接続する．
コネクションを確立することで名簿管理の処理が開始し，以降はシステムコール関数を用いたソケット通信により
以下の一連の処理を繰り返す．
\begin{enumerate}
  \item クライアントが名簿管理に関する標準入力からの入力をサーバにメッセージとして送信する
  \item サーバがクライアントからのメッセージを受信する
  \item サーバがメッセージに対応した名簿データに関する処理を行い，その結果をクライアントにメッセージとして送信する
  \item クライアントがサーバーから受信したメッセージを標準出力へ出力する
\end{enumerate}
クライアントとサーバは一方が送信処理をする際にもう一方が受信処理
を行う様に通信を同期してやりとりを行う．
処理の終了時にどちらも接続を切断し，
クライアントはプログラムを終了し，サーバは次のクライアントの
接続を待ち受ける状態となる．


プログラムで扱う名簿データは「ID，氏名，誕生日，住所，備考」の項目からなるCSV形式であり，
サーバはこの形式のデータを受信するとこれを新たな名簿データとしてメモリに保存する．
また，'\verb|%|'から始まるメッセージは名簿データに対する様々な処理を実行するためのコマンド入力であり，
サーバからクライアントへのメッセージは主にこのコマンド処理の結果である．
以下，実装したコマンドに対応した処理や機能，及び処理結果の出力について示す．

\paragraph*{\%Q コマンド}
クライアントプログラムを終了し，サーバープログラムはクライアントとの接続を終了して
次のクライアントプログラムの接続を待ち受ける状態となる．

\paragraph*{\%C コマンド}
登録した名簿データ数の表示を行う．
サーバからクライアントへ登録されている名簿データの数と，登録可能な残りのデータ数に
関するメッセージを送信する．

\paragraph*{\%P コマンド}
引数に入力された整数値に応じて登録されている名簿データを表示する．
サーバはクライアントへ該当の名簿データ全ての各項目を表示した文字列を
メッセージとして送信する．
引数の仕様を以下に示す．
\begin{itemize}
  \item $0$の場合：登録順に全件表示
  \item 負の場合：登録データの後ろから順に絶対値の数だけ表示
  \item 絶対値が総データ数以上の場合：登録順に全件表示
\end{itemize}

\paragraph*{\%R コマンド}
サーバ側で引数に指定された名前のファイルを読み込み，CSV形式で記された文字列を
名簿データとして登録を行う．

\paragraph*{\%W コマンド}
サーバ側で引数に指定された名前のファイルへ，登録されている
全ての名簿データをCSV形式で出力する．

\paragraph*{\%S コマンド}
引数で指定された整数値に対応する項目に関して，サーバプログラムのメモリに登録されている
名簿データのソートを行う．

\paragraph*{\%F コマンド}
引数に入力された文字列と完全に一致する項目を持つ名簿データ全ての
表示を行う．\%Pコマンドと同様に，サーバは該当の名簿データの情報を
メッセージとしてクライアントへ送信する．

\paragraph*{\%D コマンド}
引数に入力された整数値に応じて，サーバがメモリに保存している
名簿データを削除する機能を持つ．
引数の仕様を以下に示す．
\begin{itemize}
  \item $0$の場合：全データ削除
  \item 正の場合：先頭から引数の数だけ削除
  \item 負の場合：登録データの後ろから順に引数の絶対値の数だけ表示
  \item 絶対値が総データ数以上の場合：全データ削除
\end{itemize}

\subsection{クライアントプログラムの機能と作成方針} \label{sec:func-client}
クライアントは始めにサーバとのTCPコネクションの確立を行う処理をする．
接続にはサーバが動作する計算機のホスト名と，サーバプログラムのポート番号
が必要であり，これらの情報はプログラム実行時の引数として
入力し，これをそれぞれIPアドレス，ポート番号として接続の処理
に利用するという設計にした．

サーバとの接続が確立した後は，標準入力からの入力された文字列を
サーバへメッセージとして送信し，その後サーバの処理結果を
受信して標準出力へ出力するという処理を繰り返す．
この繰り返しの実現には，TCPの接続処理の後にループの構文を設け，
その中でメッセージの入力と送信，受信と出力の処理を行うという方針を取った．

\%Qコマンドによるプログラムの終了は，
処理の複雑化を避けるため，上記のサーバとのメッセージの送受信・同期の処理から
分岐せず，サーバからのメッセージを受信した後にループから抜ける
という設計にした．

\subsection{サーバプログラムの機能と作成方針}
サーバープログラムは，まず通信相手となるクライアントからの
接続要求を待ち受ける．この機能ではクライアント側が接続をするために，プロセス
のポート番号を設定する必要があり，これをプログラム実行時の
引数として入力された文字列を整数値として変換することで
実装を行った．

クライアントとの接続後は以下の処理を行う．
\begin{enumerate}
  \item クライアントの接続を受け付ける
  \item クライアントからのメッセージを受信する
  \item メッセージに対応した名簿管理の処理を行う
  \item 処理の結果をクライアントに送信，2の処理へ
  \item クライアントとの接続終了後，1に戻る
\end{enumerate}
処理2--4はクライアントプログラムと同様に，クライアントとの
やり取りが終了するまで繰り返されるため，ループ処理を設けて
その中に実装する方針とした．
クライアントから\%Qコマンドが送信された場合は
接続の終了を示すメッセージを送信してクライアントとの接続を終了した後，
プログラムはプロセスを終了せず，次のクライアントプログラムの接続を待ち受ける
ため，処理1--5を無限ループの処理の中に設けることで実現した．
そのため，サーバプログラムの終了はキーボードのCtrl-C入力もしくは
\verb|kill|コマンドで行う．
Ctrl-C入力は本来強制的にプロセスを終了させるが，本プログラムは\ref{sec:sec1-ad1}
項に示す様に安全に終了する機能を持つ．


\subsubsection{多重通信受付対応機能 (発展課題2)} \label{sec:ad2-multi}
今回作成したサーバプログラムは複数のクライアントのプロセスから
の接続を同時に処理することが可能な多重通信受け付け機能を持つ．
実現にあたっては，
接続の待ち受けをする処理と
コネクションを確立し名簿管理のデータ通信を行う処理を
分けるという仕組みが有効であると考え，
接続要求の待ち受けを主に行う元のサーバプログラムを親プロセスとして
TCPコネクションの確立の後にそれぞれのクライアントに対応した通信処理を行う
プロセスを複製する方針により実装を行った．
処理の概要については第\ref{sec:prog-server}節に示す．

\subsubsection{サーバログ機能 (発展課題3)} \label{sec:ad3-log}
社会で利用されるサーバプログラムやシステムでは
情報の管理・分析やセキュリティ対策のために接続元の
IPアドレス等の情報，アクセスした時刻やイベントを
ログとして記録することが多い．
そのため，本演習で作成したプログラムにおいても
サーバ側で様々な情報をログとして記録する機能を実装した．

ログに記録する情報は接続元のIPアドレスとポート番号，
実行されたコマンドとメッセージにより登録された名簿データである．
ログファイルの作成は
クライアントとのTCPコネクション確立に行い，
メッセージの送受信のループ処理の直前で
その時点での時刻と接続元のIPアドレスとポート番号をファイルへ書き込む．
クライアントから受信したデータに関しては，実行可能なコマンド
と登録可能な形式の名簿データのみを書き込む．

\subsubsection{クライアントプログラム停止時の一時データ記録と復帰処理 (発展課題3)} \label{sec:ad3-original}
サーバプログラムは，クライアントとのやりとりと通信の終了を\%Qコマンドのメッセージ受信により行う．
しかし，クライアントプログラムがヒューマンエラー等の理由によりCtrl-C入力で
終了した場合は扱っていた名簿データが保存されないまま失われてしまう．
そのため，サーバ側でクライアントがCtrl-C入力で終了したことを検知し，
それを異常終了とみなして一時的にファイルへその時点で保存している名簿データを書き出し，
以降接続するクライアントにその一時データを読み込む選択ができる機能を実装した．

一時的に記録したファイルがある場合は新たに接続したクライアントに
メッセージを送信に，そのデータを読み込むがどうかを選択させ，
選択された場合はファイルの内容を名簿データとして読み込んだ上で一時ファイルを削除する．
選択されなかった場合はそのファイルを削除せず，データも読み込まない．

\subsubsection{Ctrl-C入力時の安全なプログラムの終了処理 (発展課題3)} \label{sec:ad3-crtlc}
サーバプログラムはクライアントの接続要求を待ち受けるために
無限ループの処理を設けており，プロセスの終了には
Ctrl-C入力により強制終了させる方法がある．
しかし，この場合では通信で使用している待ち受け用のソケット，
クライアント用のソケットの削除，\ref{sec:ad3-log}項で示した
ログファイルのファイルディスクリプタの削除など，
本来プロセスを終了する前に行うべき処理が行われない．
そのため，サーバプログラムではCtrl-C入力時にこれらの処理を行い安全に終了する
機能を実装した．この機能では，上記の処理に
状態のままになることを防ぐために
Ctrl-C入力時にはプロセスにキーボードからの割り込みを示す
シグナルが送信されるため，機能の実装にはプログラムで\verb|signal| システムコール
を利用して，このシグナル発生時に上記の行うべき処理，
加えてクライアントプログラムがサーバからの受信待ち状態のままになること
を防ぐためのメッセージの送信を行い
プロセスを終了する方針をとった．

%--------------------------------------------------------------------%
\section{プログラムの処理の説明}
サーバ・クライアントのプロセスは第\ref{sec:prog-flow}節
で示した様にTCPコネクションを確立した後に，相互に送信と受信の対応を同期させて
メッセージのやりとりを行う．これら一連の処理の流れについて
\begin{enumerate}
  \item サーバ・クライアントのコネクションの確立
  \item サーバの安全なプロセス終了処理の設定(発展課題3)
  \item クライアントの標準入力からの入力データ取得・サーバへのメッセージ送信
  \item サーバのメッセージ受信
  \item サーバの受信メッセージによる名簿データの処理，クライアントへの処理結果のメッセージ送信
  \item クライアントのメッセージ受信と標準出力への出力
\end{enumerate}
に分けて解説する．

\subsection{サーバ・クライアントのコネクションの確立}
\subsubsection{サーバプログラム} \label{sec:prog-server}
サーバプログラムは，始めにクライアントの接続要求の受け付け処理を行う．
まずソケットの待ち受けの設定を行うために\verb|sockaddr_in|構造体の変数を
宣言し，これに対して
\begin{itemize}
  \item ソケットで利用するアドレスタイプにIPv4(\verb|AF_INET|)を設定する
  \item プログラム実行時の引数で受け取った文字列をポート番号として\verb|atoi|関数により変換
  した整数値を\verb|htons|関数を用いてネットワークバイトオーダに変換して設定する
  \item どのアドレスからの要求を受け付けるために，受け付けるIPアドレスの項目を\verb|INADDR_ANY|として
  \verb|htonl|関数によりネットワークバイトオーダに変換して設定する．
\end{itemize}
という処理を行う．
次に\verb|socket|関数にソケットで利用するアドレスタイプとして第1引数にIPv4を指定する\verb|AF_INET|を，
第2引数に通信形式としてTCPを指定する\verb|SOCK_STREAM|を設定して，ソケットの生成及びその戻り値として
ディスクリプタの値を受け取る．このディスクリプタの値と先述の\verb|sockaddr_in|
構造体の変数を用いて\verb|bind|関数によりソケットに待ち受けるための設定を行う．

待ち受け用のソケットを作成した後，そのディスクリプタを引数として
\verb|listen|関数によりサーバとしてクライアントの接続待ち受けを開始する．
第2引数に設定する一度に通信する上限のクライアント数は$5$と設定した．
次に，クライアントとの接続要求の受付を行うためのループ処理に進む．
この中の処理の始めで待ち受け用のソケットのディスクリプタを引数として\verb|accept|関数で
接続要求を受け取り，クライアントとの通信に使用するソケットを生成する．
この時，\verb|accept|関数の引数に\verb|adddinfo_in|
構造体の変数のポインタを\verb|sockaddr|構造体のポインタにキャストして渡し，
クライアントの情報を取得し，この変数を用いて第\ref{sec:ad3-log}項で示したログ機能により
\verb|open|関数によるクライアント用のログファイルの作成とクライアントのIPアドレスとポート番号，時刻の記入を行う．


クライアントとの通信を行うソケットの生成を行った後，第\ref{sec:ad2-multi}項で示した多重通信受付
のために\verb|fork|関数によりその時点での処理の進行，メモリ状態が同じであるプロセスの複製を行う．
この時の戻り値として受け取ったプロセスIDが0より大きい親プロセスと
プロセスIDが0である複製された子プロセス
で処理を\verb|if|文により分岐させ，それぞれ以下の処理を行う．
\begin{description}
  \item[親プロセス] 接続したクライアントとのメッセージ送受信の処理は行わず，再びループの始めに戻り，\verb|accept|関数で次のクライアントの接続待ち受ける．
  \item[子プロセス] 始めに第\ref{sec:ad3-original}項で示した一時記録された名簿データの読み込み
  を選択する処理を行う．その後，クライアントとのメッセージのやりとりを行うループの処理に入る．
  クライアントとの通信の終了後はクライアントの接続要求を受け付けるループ処理を抜け，クライアントとの通信用ソケットを\verb|close|関数で削除してプロセスを終了する．
  また，この時ログ機能により作成したファイルのディスクリプタも\verb|close|関数により削除する．
\end{description}
これによって
\begin{itemize}
  \item 親プロセスはクライアントの接続要求を受け続ける処理を繰り返す
  \item 子プロセスはクライアントとのメッセージの送受信を行い，通信終了後にプロセスを終了する
\end{itemize}
という処理の流れになり，複数のクライアントのプロセスからの接続要求を同時に処理する
ことができる．

\subsubsection{クライアントプログラム}
クライアントプログラムは始めに，
接続先のサーバプロセスとのTCPコネクションの確立の処理をする．
サーバに接続するために必要なサーバプロセスの
ホスト名とポート番号はプログラム実行時に引数として文字列データとして
受け取るため，こを引数として
\verb|getaddrinfo|関数によって，ソケットの生成に必要な項目の値が設定された\verb|addrinfo|
構造体のデータを取得する．
このデータを利用して\verb|socket|関数によりサーバとの接続に利用する
ソケットのディスクリプタを得て，この値を引数に\verb|connect|関数により
サーバとの接続を確立する．
コネクションの確立後は\verb|while|文の中で
以降解説するサーバとのやりとりを繰り返し行う．

\subsection{サーバの安全なプロセス終了処理の設定(発展課題3)} \label{sec:prog-ad3-original}
サーバでは，第\ref{sec:ad3-crtlc}項に示したCtrl-C入力時の安全なプロセスの
終了処理を待ち受け用ソケットを作成した後に設けている．
プログラムでは\verb|signal|関数により，Ctrl-C入力時にプロセスに送信される\verb|SIGINT|
シグナルを第1引数として，第2引数にプロセス終了前に行う処理をまとめた関数を渡す．
この関数では，待ち受け用のソケットのディスクリプタとログファイルのディスクリプタの削除と，クライアント
がサーバからのメッセージ受信待ち状態のままになることを防ぐための
目印となるメッセージの送信を行う．
このメッセージは1バイトで，名簿管理に関するメッセージで使用されないASCIIコードの整数値$127$(\verb|0x7f|)
を代入している．

\subsection{クライアントの標準入力からのデータ取得・サーバへのメッセージ送信} \label{sec:prog-client-send}
標準入力からの入力データの受け取りとサーバへのメッセージの送信は
同じ\verb|while|文中で行い，以下の流れで一連の処理を行う．

まず標準入力からの
入力データをシステムコール関数の\verb|read|により取得し，サイズが$10$バイトのバッファー(\verb|char|型の配列)
に格納する．そしてこのバッファーと\verb|read|関数の戻り値である取得したバイト数を引数として，
\verb|send|関数によりサーバへメッセージを送信する．
ユーザからのメッセージ入力の終了はEnterキーの押下による改行文字を目印とし，
\verb|read|関数の処理後に取得バイト数を利用して入力文字列の末尾の改行文字(\verb|'\n'|)があるかを確認し，
あればその要素を送信終了を示す目印としてメッセージで利用しないASCIIコードの整数値$3$(\verb|0x03|)に変更し，
\verb|send|関数により送信した後にループ処理から抜ける．
その後，サーバからのメッセージを受信する処理へ移行する．

\subsection{サーバのメッセージ受信}
クライアントからのデータ受信はクライアントの送信処理と同様に\verb|while|文中で
システムコール関数の\verb|read|により取得し，サイズが$10$バイトの受信用バッファー(\verb|char|型の配列)
に格納することを繰り返す．ここで，名簿管理に使用するメッセージは連結した1つの文字列データとして
扱うため，予め宣言した最大入力文字数($1024$)$ + 1$を格納できる\verb|char|型のメッセージ用バッファー
へ読み込んだバッファーの内容をコピーを行う．この処理は以下の流れにより行う．
\begin{enumerate}
  \item \verb|while|文の直前で名簿管理処理用のメッセージ用バッファーの先頭アドレスをポインタ変数に格納する
  \item \verb|while|文の繰り返し処理において，\verb|read|関数の処理後，
  戻り値の取得バイト数だけ\verb|strncpy|関数により受信用バッファーの内容を先述のポインタの位置へコピーする
  \item 上記ポインタ変数を取得バイト数だけ加算する．
\end{enumerate}
これにより，繰り返し受信したデータを連結したメッセージとして保存を行う．
受信処理の終了は，\verb|read|関数の処理後に
受信用バッファー内にクライアントプログラムにより付与された送信終了の目印である
整数値$3$(\verb|0x03|)があるかを確認し，
ある場合はその要素を終端文字(\verb|'\0'|)へ変更し，メッセージ用バッファーへのコピー後
に受信のループ処理を抜ける．
このメッセージ中の送信終了の目印により，クライアントの\verb|send|による送信回数に依らず，
サーバはメッセージの受信を適切に終了を行う．

\subsection{サーバの受信メッセージによる名簿データの処理・クライアントへのメッセージ送信}
メッセージの受信後，メッセージ用バッファーに格納した文字列を解析して名簿管理に関する処理を行う．
この時，メッセージが実行可能なコマンドまたは登録可能な名簿データである場合は第\ref{sec:ad3-log}
項で示したログファイルに書き込む．
処理の結果，クライアント側にメッセージを送る場合は，
クライアントの送信処理と同様にサイズが$10$バイトの送信用バッファーを用いて，
終端文字も含めたメッセージのバイト数を$10$バイトずつ分割して
必要な回数だけ\verb|send|関数によりクライアントへデータの送信を繰り返す．

この処理の後，
受信メッセージが\%Qコマンドで
ない場合はサーバのメッセージ送信終了の目印として，整数値3(\verb|0x03|)を代入した
1バイトのデータを\verb|send|関数により送信し，次のクライアントプログラムからのメッセージを受信する処理へ
移行する．\%Qコマンドであった場合は，
このデータをクライアントへ接続終了を示す目印として，メッセージ終了の目印と同様に
通常のメッセージで使用されないASCIIコードの整数値$4$(\verb|0x04|)を代入して送信し，
クライアントとのメッセージのやりとりを行うループ処理を抜け，クライアントとの通信用ソケットを\verb|close|関数
により削除する．

以上の様に，コマンドにより名簿管理に関するメッセージの送信をするかどうかに
関わらず，必ずクライアント側へサーバの処理が終了したことを表す目印を
メッセージと送信を行う．これによりクライアントの受信処理を終了させ，送受信の同期を行う．

\subsection{クライアントのサーバからのメッセージ受信・標準出力への出力}
サーバからのメッセージの受信と標準出力への出力は第\ref{sec:prog-client-send}項
で解説した処理と同様に，\verb|while|文中で行い，
以下の流れで処理を行う．

まずサーバからの送信されたデータを\verb|recv|関数によりサイズが$10$バイトの受信用バッファー
に格納し，
この受信用バッファーのメッセージをシステムコール関数の\verb|write|関数により，標準出力へ
\verb|recv|関数の戻り値である取得したバイト数だけ出力する．
メッセージ出力処理の後はサーバのクライアントメッセージの受信処理と同様に
バッファー内にサーバが施したメッセージの終了に関する目印に該当する要素があるかを確認し，あれば以下の処理を行う．
\begin{description}
  \item[整数値$3$(\texttt{0x03})] メッセージの送信終了を示し，
  受信処理のループを抜け，再びユーザからの入力とサーバへのメッセージ送信
  を行う処理へ移行する．
  \item[整数値$4$(\texttt{0x04})] \%Qコマンド入力判定による通信の接続終了を示し，
  サーバとのメッセージ送受信処理のループを抜け，ソケットを\verb|close|関数により削除してプロセスを終了する．
\end{description}
また，\verb|recv|関数による受信データの取得後は，メッセージ出力前に第\ref{sec:prog-ad3-original}節
で解説したサーバ側のプロセス終了を示す目印としてメッセージに整数値$127$(\verb|0x7f|)
が含まれているかどうかを確認し，あれば上記の\%Qコマンド入力判定時の接続終了と
同じ処理を行う．

%--------------------------------------------------------------------%
\section{プログラムの使用方法と使用例}

\subsection{他学生のサーバプログラムとの通信}

\subsection{多重通信受付機能の使用}

%--------------------------------------------------------------------%
\section{プログラムの作成過程に関する考察}


%--------------------------------------------------------------------%
\section{得られた結果に関する考察}


%--------------------------------------------------------------------%

% Verbatim environment
% プリアンブルで \usepackage{fancyvrb} が必要．
%   - numbers           行番号を表示．left なら左に表示．
%   - xleftmargin       枠の左の余白．行番号表示用に余白を与えたい．
%   - numbersep         行番号と枠の間隙 (gap)．デフォルトは 12 pt．
%   - fontsize          フォントサイズ指定
%   - baselinestretch   行間の大きさを比率で指定．デフォルトは 1.0．
% \begin{Verbatim}[numbers=left, xleftmargin=10mm, numbersep=6pt,
%                     fontsize=\small, baselinestretch=0.8]
% #include <stdio.h>

% int main()
% {
%     char s[4] = {'A', 'B', 'C', '\0'};

%     printf("s = %s\n", s);

%     return 0;
% }
% \end{Verbatim}

%--------------------------------------------------------------------%
% 参考文献
%   以下は，書き方の例である．実際に，参考にした書籍等を見て書くこと．
%   本文で引用する際は，\cite{book:algodata}などとすればよい．
% \begin{thebibliography}{99}
%   \bibitem{book:algodata} 平田富雄，アルゴリズムとデータ構造，森北出版，1990.
%   \bibitem{book:label2} 著者名，書名，出版社，発行年.
%   \bibitem{www:label3} WWWページタイトル，URL，アクセス日.
% \end{thebibliography}

%--------------------------------------------------------------------%
%% 本文はここより上に書く（\begin{document}～\end{document}が本文である）
\end{document}
