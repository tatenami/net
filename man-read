READ(2)                    Linux Programmer's Manual                   READ(2)

名前
       read - ファイルディスクリプターから読み込む

書式
       #include <unistd.h>

       ssize_t read(int fd, void *buf, size_t count);

説明
       read()  はファイルディスクリプター (file descriptor)  fd から最大 count
       バイトを buf で始まるバッファーへ読み込もうとする。

       seek に対応しているファイルでは、read  は現在のファイルオフセットから行
       われ、ファイルオフセットは読み込んだバイト数分だけ進められる。現在の
       ファイルオフセットがファイル末尾かそれより先の場合は、読み出しは行われ
       ず、 read() は 0 を返す。

       count が 0 の場合、 read() は以下で説明するエラーを検出する場合がある。
       どのエラーもなかった場合、もしくは read()  がエラーのチェックを行わない
       場合、 count が 0 で呼び出された read() は 0 を返し、何も行わない。

       count が SSIZE_MAX より大きければ、結果は規定できない。

返り値
       成功した場合、読み込んだバイト数を返す (0 はファイルの終りを意味する)。
       ファイル位置はこの数だけ進められる。 この数が要求した数より小さかったと
       してもエラーではない;    例えば今すぐには実際にそれだけの数しかない場合
       (ファイルの最後に近いのかも しれないし、パイプ (pipe) や端末 (terminal)
       から読み込んでいるかもしれない) や read()  がシグナル (signal) によって
       割り込まれた場合にこれは起こりえる。   エラーの場合は、-1    が返され、
       errno  が適切に設定される。この場合はファイル位置が変更されるかどうかは
       不定である。

エラー
       EAGAIN ファイルディスクリプター fd がソケット以外のファイルを参照してい
              て、  非停止  (nonblocking)  モード (O_NONBLOCK)  に設定されてお
              り、読み込みを行うと停止する状況にある。

       EAGAIN または EWOULDBLOCK
              ファイルディスクリプター   fd   がソケットを参照していて、非停止
              (nonblocking) モード (O_NONBLOCK) に設定されており、読み込みを行
              うと停止する状況にある。  POSIX.1-2001  は、この場合にどちらのエ
              ラーを返すことも認めており、 これら 2 つの定数が同じ値を持つこと
              も求めていない。    したがって、移植性が必要なアプリケーションで
              は、両方の可能性を 確認すべきである。

       EBADF  fd    が有効なファイルディスクリプターでないか、読み込みのために
              オープン (open) されていない。

       EFAULT buf がアクセス可能なアドレス空間の外にある。

       EINTR  何のデータも読み込まないうちにシグナルに割り込まれた。 signal(7)
              参照。

       EINVAL fd  は読み込みに適していないオブジェクトを参照している。  もしく
              は、ファイルが  O_DIRECT  フラグを指定してオープンされているが、
              buf に指定されたアドレス、 count に指定された値、 現在のファイル
              オフセットのいずれかの アラインメントが不適切である。

       EINVAL fd が timerfd_create(2)  の呼び出しで作成されたが、 read()  に間
              違ったサイズのバッファーが渡された。              さらなる情報は
              timerfd_create(2)  を参照のこと。

       EIO    I/O エラー。これは例えばプロセスがバックグランドプロセスグループ
              で、それを制御している端末から読み込もうとし、   SIGTTIN  が無視
              (ignore) または禁止 (blocking) されている場合や、 そのプロセスグ
              ループが孤立  (orphan) している場合に起こる。 またディスクやテー
              プを読んでいる時に低レベル I/O エラー が発生した場合にも起こる。

       EISDIR fd がディレクトリを参照している。

       fd  が接続しているオブジェクトによっては他のエラーも起こりえる。  POSIX
       では、  いくらかのデータを読んだ後に割り込みが起こった場合、 read()  は
       (errno に EINTR を設定して) -1 を返してもよいし、  既に読み込んだバイト
       数を返してもよい。

準拠
       SVr4, 4.3BSD, POSIX.1-2001.

注意
       NFS において。少量のデータを読み込む場合、最初の時のみにタイム スタンプ
       が更新され、続くコールでは更新されないだろう。 これはクライアント側で属
       性のキャッシングを行なうためである。  なぜならば、もし全ての NFS クライ
       アントが  st_atime  (最終ファイルアクセス時刻)   の更新をサーバーに送ら
       ず、クライアント側でキャッシュを読むことに満足して いれば、サーバー側で
       の read は発生しないので st_atime の更新は行なわれからだ。 UNIX  の方式
       では、クライアント側の属性のキャッシングを無効にすることで、 これを得る
       ことができる。しかしほとんどの状況ではこれは続くサーバーの 負荷を増加さ
       せ、パフォーマンスの低下をもたらす。

バグ
       POSIX.1-2008/SUSv4  セクション  XSI  2.9.7  ("Thread  Interactions with
       Regular File Operations") によると、

           以下のすべての関数では、 通常ファイルもしくはシンボリックリンクに対
           する操作では  POSIX.1-2008 で規定された効果が互いにアトミックに行わ
           れなければならない: ...

       この後に書かれている API の中に read() と readv(2) である。  スレッド（
       やプロセス)  間でアトミックに適用することが求められる効果の一つとして、
       ファイルオフセットの更新がある。 しかしながら、 バージョン 3.14  より前
       の  Linux  では、  この限りではない。  オープンファイル記述  (open file
       description) を共有する 2 つのプロセスが同時に read() (や readv(2))  を
       実行した場合、  この I/O 操作ではファイルオフセットの更新に関してはアト
       ミックではなく、 2 つのプロセスの read で取得されるデータブロックが (間
       違って) 重なる可能性がある。 この問題は Linux 3.14 で修正された。

関連項目
       close(2),  fcntl(2), ioctl(2), lseek(2), open(2), pread(2), readdir(2),
       readlink(2), readv(2), select(2), write(2), fread(3)

この文書について
       この man ページは Linux man-pages プロジェクトのリリース 3.79 の一部 で
       ある。プロジェクトの説明とバグ報告に関する情報は
       http://www.kernel.org/doc/man-pages/ に書かれている。

Linux                             2014-05-04                           READ(2)
